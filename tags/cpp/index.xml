<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on LongLP</title><link>https://philong6297.github.io/tags/cpp/</link><description>Recent content in cpp on LongLP</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 31 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://philong6297.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Dymanic Memory Cost and Optimization Strategies: Allocation Speed</title><link>https://philong6297.github.io/posts/dynamic_memory_cost_and_optimization_strategies_allocation_speed/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://philong6297.github.io/posts/dynamic_memory_cost_and_optimization_strategies_allocation_speed/</guid><description>1. Introduction Link to heading When it comes to memory usage, there are (typically) two types of programs. The first type is programs that allocate memory in large blocks. Usually, they know precisely how much memory they will need and can allocate it in advance. Think about it like you are creating a monolith of memory with fixed size and use this resource in your entire program lifetime, no less.</description></item><item><title>About inlining</title><link>https://philong6297.github.io/posts/about_inlining/</link><pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate><guid>https://philong6297.github.io/posts/about_inlining/</guid><description>Introduction Link to heading For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:
Inlining is often misused in development, which results in counter-productive and risky situations.
I will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid.</description></item></channel></rss>