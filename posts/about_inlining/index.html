<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>About inlining | LongLP</title><meta name=keywords content="cpp"><meta name=description content="Introduction For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:
Inlining is often misused in development, which results in counter-productive and risky situations.
I will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid."><meta name=author content="longlp"><link rel=canonical href=https://philong6297.github.io/posts/about_inlining/><link crossorigin=anonymous href=/assets/css/stylesheet.2e47ffddd5e3f5568a7da09828f5950ef07511824dcadb34c30c775ea3549464.css integrity="sha256-Lkf/3dXj9VaKfaCYKPWVDvB1EYJNyts0wwx3XqNUlGQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.8f4558fe13d35bf64986a19e09ff0c1eb791cc6d8c81193b52bdc48d24f1f22b.js integrity="sha256-j0VY/hPTW/ZJhqGeCf8MHreRzG2MgRk7Ur3EjSTx8is=" onload=hljs.highlightAll()></script>
<link rel=icon href=https://philong6297.github.io/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://philong6297.github.io/images/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://philong6297.github.io/images/favicon-32x32.png><link rel=apple-touch-icon href=https://philong6297.github.io/images/apple-touch-icon.png><link rel=mask-icon href=https://philong6297.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="About inlining"><meta property="og:description" content="Introduction For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:
Inlining is often misused in development, which results in counter-productive and risky situations.
I will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid."><meta property="og:type" content="article"><meta property="og:url" content="https://philong6297.github.io/posts/about_inlining/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-20T00:00:00+00:00"><meta property="article:modified_time" content="2021-11-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="About inlining"><meta name=twitter:description content="Introduction For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:
Inlining is often misused in development, which results in counter-productive and risky situations.
I will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://philong6297.github.io/posts/"},{"@type":"ListItem","position":3,"name":"About inlining","item":"https://philong6297.github.io/posts/about_inlining/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"About inlining","name":"About inlining","description":"Introduction For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:\nInlining is often misused in development, which results in counter-productive and risky situations.\nI will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid.","keywords":["cpp"],"articleBody":"Introduction For me, every time I encounter the inline keyword in codebase and document myself about it, I still end up with the same conclusions:\nInlining is often misused in development, which results in counter-productive and risky situations.\nI will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid.\nDefinition From the C++ standard definition of inline:\nThe original intent of the inline keyword was to serve as an indicator to the optimizer that inline substitution of a function is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.\nSince this meaning of the keyword inline is non-binding, compilers are free to use inline substitution for any function that’s not marked inline, and are free to generate function calls to any function marked inline. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above.\nSource : inline specifier – cppreference.com\nWhat we need to notice from that are the followings:\ninline is used to avoid function overhead, replacing the call by the implementation at compile time. This keyword is only a hint, not a command, given to the compiler. No matter how you designate a function as inline, it is a request that the compiler is allowed to ignore: the compiler might inline-expand some, all, or none of the places where you call a function designated as inline (I really wish the keyword will be maybe_inline in the future). With that in mind, let’s take a tour of the pros and the cons of this feature.\nPros First of all, even if it is just a hint, the keyword still has a chance to influence the compiler. It may not, but it also may. For instance, we can think of the stupidest compiler which will just strictly respect the inline keyword, without trying to analyze the context and optimize itself. This is not against the standard (according to the C++11 standard §12.1.5) and the keyword is useful in this case. Do not get discouraged if that seems to be hopelessly vague. The flexibility of the above is actually a huge advantage: it lets the compiler treat large functions differently from small ones, plus it lets the compiler generate code which is easy to debug if you select the right compiler options.\nTo be summarized, the pros are:\nIt speeds up your program by avoiding function calling overhead. It saves the overhead of variables’ push/pop on the stack when the function is called. It saves the overhead of return call from a function. It increases the locality of reference by utilizing instruction cache. By marking it as inline, you can put a function definition in a header file (i.e. it can be included in multiple compilation units, without the linker complaining). The first three benefits are overall the main benefits of this feature and the original goal of the introduction of this keyword. Those who know a bit of assembly know that pushing a lot of parameters on the stack to call function can cost more instructions that the function holds.\nPoint number 4 seems to be a non-negligible side-benefit of this method, but since instruction cache is far from being my specialty, I will not expand on that.\nThe last one is pro only in certain specific cases, but still pro nonetheless.\nCons It increases the executable size due to code expansion. C++ inlining is resolved at compile time. This means if you change something in the inlined function, you would need to recompile the whole source codes using the function to make sure it will be updated. When used in a header, it makes your header file larger with information that users do not care about. As mentioned above it increases the executable size, which may cause thrashing in memory. More page faults bring down your program performance. Sometimes inlining is not useful. For example, in the embedded system where large executable size is not preferred at all due to memory constraints. Points 1 and 4 are the main reasons that inlining functions can decrease performance. These are crucial for keeping in your mind when using this feature.\nPoint 2 can be a major inconvenience, depending on your project.\nIn my point of view, point 3 is the main drawback of inlining. In order to have maintainable code, you need to make sure all your code be clear and organized. Inlining is a huge code smell in that regard.\nThe last one is listed for specific projects, so I won’t expand further. But keep in mind that if you have memory constraints, inlining may have consequences.\nConlusion: When to use the inline keyword? Avoiding function overhead is only useful if you are in a performance-critical part of your code.\nWe probably already know Pareto’s law:\n80% of the execution happens in 20% of the code.\nThat means that the program spends most of its time around bottlenecks. Thus, if you inline code which is not within a bottleneck, this will have little to ZERO effect on your program performance, while increasing its size significantly.\nI saw several codebases polluted by useless inline in non-critical code. There is absolutely no need in decreasing the readability of your source while increasing its executable sizes.\nHere is my opinion:\nDo not use inline until you have proofs from the performance benchmark and you are sure it is inside a bottleneck.\nThis is the only way to achieve both efficiency and cleanliness.\nAbout “All In One Line” code style - another type of inlining If you are someone who likes to write something like this one:\n1 inline auto set_value(const int32_t i) noexcept { value_ = i; } By using the prototype and the implementation all on one line, you prevent several debuggers from doing their jobs properly.\nFor instance, in Visual Studio, if you put a breakpoint inside the set_value method when it’s hit, the debugger won’t be able to give you the value of the value_ variable.\nJust stop doing that. It won’t cost you much to add a new line:\n1 2 3 inline auto set_value(const int32_t i) noexcept { value_ = i; // put your breakpoint in here } ","wordCount":"1106","inLanguage":"en","datePublished":"2021-11-20T00:00:00Z","dateModified":"2021-11-20T00:00:00Z","author":{"@type":"Person","name":"longlp"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://philong6297.github.io/posts/about_inlining/"},"publisher":{"@type":"Organization","name":"LongLP","logo":{"@type":"ImageObject","url":"https://philong6297.github.io/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://philong6297.github.io accesskey=h title="LongLP (Alt + H)">LongLP</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://philong6297.github.io/archives title=Archives><span>Archives</span></a></li><li><a href=https://philong6297.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://philong6297.github.io>Home</a>&nbsp;»&nbsp;<a href=https://philong6297.github.io/posts/>Posts</a></div><h1 class=post-title>About inlining</h1><div class=post-meta><span title='2021-11-20 00:00:00 +0000 UTC'>November 20, 2021</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;longlp</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#introduction>Introduction</a></li><li><a href=#definition>Definition</a></li><li><a href=#pros>Pros</a></li><li><a href=#cons>Cons</a></li><li><a href=#conlusion-when-to-use-the-inline-keyword>Conlusion: When to use the <code>inline</code> keyword?</a></li><li><a href=#about-all-in-one-line-code-style---another-type-of-inlining>About &ldquo;All In One Line&rdquo; code style - another type of inlining</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>For me, every time I encounter the <code>inline</code> keyword in codebase and document myself about it, I still end up with the same conclusions:</p><blockquote><p>Inlining is often misused in development, which results in counter-productive and risky situations.</p></blockquote><p>I will try to summarize all the aspects which I believe we need to remember about inlining, giving pros, cons and situations when it can be used and when we should avoid.</p><h2 id=definition>Definition<a hidden class=anchor aria-hidden=true href=#definition>#</a></h2><p>From the C++ standard definition of <code>inline</code>:</p><blockquote><p>The original intent of the <code>inline</code> keyword was to serve as an indicator to the optimizer that <a href=https://en.wikipedia.org/wiki/Inline_expansion>inline substitution of a function</a> is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</p></blockquote><blockquote><p>Since this meaning of the keyword <code>inline</code> is non-binding, compilers are free to use inline substitution for any function that&rsquo;s not marked <code>inline</code>, and are free to generate function calls to any function marked <code>inline</code>. Those optimization choices do not change the rules regarding multiple definitions and shared statics listed above.</p></blockquote><p>Source : <a href=https://en.cppreference.com/w/cpp/language/inline>inline specifier – cppreference.com</a></p><p>What we need to notice from that are the followings:</p><ul><li><code>inline</code> is used to avoid function overhead, replacing the call by the implementation at compile time.</li><li>This keyword is only a <em><strong>hint</strong></em>, not a <em><strong>command</strong></em>, given to the compiler. No matter how you designate a function as <code>inline</code>, it is a request that the compiler is <em><strong>allowed to ignore</strong></em>: the compiler <strong>might</strong> inline-expand some, all, or none of the places where you call a function designated as inline (I really wish the keyword will be <code>maybe_inline</code> in the future).</li></ul><p>With that in mind, let’s take a tour of the pros and the cons of this feature.</p><h2 id=pros>Pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h2><p>First of all, even if it is just a <em><strong>hint</strong></em>, the keyword <strong>still</strong> has a chance to influence the compiler. It may not, but it also may. For instance, we can think of the stupidest compiler which will just strictly respect the <code>inline</code> keyword, without trying to analyze the context and optimize itself. This is not against the standard (according to the C++11 standard §12.1.5) and the keyword <em><strong>is</strong></em> useful in this case. Do not get discouraged if that seems to be hopelessly vague. The flexibility of the above is actually a huge advantage: it lets the compiler treat large functions differently from small ones, plus it lets the compiler generate code which is easy to debug if you select the right compiler options.</p><p>To be summarized, the pros are:</p><ol><li>It speeds up your program by avoiding function calling overhead.</li><li>It saves the overhead of variables&rsquo; push/pop on the stack when the function is called.</li><li>It saves the overhead of return call from a function.</li><li>It increases the locality of reference by utilizing instruction cache.</li><li>By marking it as inline, you can put a function definition in a header file (i.e. it can be included in multiple compilation units, without the linker complaining).</li></ol><p>The first three benefits are overall the main benefits of this feature and the original goal of the introduction of this keyword. Those who know a bit of assembly know that pushing a lot of parameters on the stack to call function can cost more instructions that the function holds.</p><p>Point number 4 seems to be a non-negligible side-benefit of this method, but since instruction cache is far from being my specialty, I will not expand on that.</p><p>The last one is pro only in certain specific cases, but still pro nonetheless.</p><h2 id=cons>Cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h2><ol><li>It increases the executable size due to code expansion.</li><li>C++ inlining is resolved at compile time. This means if you change something in the inlined function, you would need to recompile the whole source codes using the function to make sure it will be updated.</li><li>When used in a header, it makes your header file larger with information that users do not care about.</li><li>As mentioned above it increases the executable size, which may cause thrashing in memory. More page faults bring down your program performance.</li><li>Sometimes inlining is not useful. For example, in the embedded system where large executable size is not preferred at all due to memory constraints.</li></ol><p>Points 1 and 4 are the main reasons that inlining functions can decrease performance. These are crucial for keeping in your mind when using this feature.</p><p>Point 2 can be a major inconvenience, depending on your project.</p><p>In my point of view, point 3 is the main drawback of inlining. In order to have maintainable code, you need to make sure all your code be clear and organized. Inlining is a huge code smell in that regard.</p><p>The last one is listed for specific projects, so I won&rsquo;t expand further. But keep in mind that if you have memory constraints, inlining may have consequences.</p><h2 id=conlusion-when-to-use-the-inline-keyword>Conlusion: When to use the <code>inline</code> keyword?<a hidden class=anchor aria-hidden=true href=#conlusion-when-to-use-the-inline-keyword>#</a></h2><p>Avoiding function overhead is only useful if you are in a performance-critical part of your code.</p><p>We probably already know Pareto’s law:</p><blockquote><p>80% of the execution happens in 20% of the code.</p></blockquote><p>That means that the program spends most of its time around bottlenecks. Thus, if you inline code which is not within a bottleneck, this will have little to ZERO effect on your program performance, while increasing its size significantly.</p><p>I saw several codebases polluted by useless <code>inline</code> in non-critical code. There is absolutely no need in decreasing the readability of your source while increasing its executable sizes.</p><p>Here is my opinion:</p><blockquote><p><strong>Do not use <code>inline</code> until you have proofs from the performance benchmark and you are sure it is inside a bottleneck.</strong></p></blockquote><p>This is the only way to achieve both efficiency and cleanliness.</p><h2 id=about-all-in-one-line-code-style---another-type-of-inlining>About &ldquo;All In One Line&rdquo; code style - another type of inlining<a hidden class=anchor aria-hidden=true href=#about-all-in-one-line-code-style---another-type-of-inlining>#</a></h2><p>If you are someone who likes to write something like this one:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=k>auto</span> <span class=nf>set_value</span><span class=p>(</span><span class=k>const</span> <span class=kt>int32_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span> <span class=n>value_</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>By using the prototype and the implementation all on one line, you prevent several debuggers from doing their jobs properly.</p><p>For instance, in Visual Studio, if you put a breakpoint inside the <code>set_value</code> method when it&rsquo;s hit, the debugger won’t be able to give you the value of the <code>value_</code> variable.</p><p>Just stop doing that. It won’t cost you much to add a new line:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=k>auto</span> <span class=nf>set_value</span><span class=p>(</span><span class=k>const</span> <span class=kt>int32_t</span> <span class=n>i</span><span class=p>)</span> <span class=k>noexcept</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>value_</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=c1>// put your breakpoint in here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><hr><footer class=post-footer><ul class=post-tags><li><a href=https://philong6297.github.io/tags/cpp/>cpp</a></li></ul><nav class=paginav><a class=prev href=https://philong6297.github.io/posts/dynamic_memory_cost_and_optimization_strategies_allocation_speed/><span class=title>« Prev</span><br><span>Dymanic Memory Cost and Optimization Strategies: Allocation Speed</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 Phi-Long Le</span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>